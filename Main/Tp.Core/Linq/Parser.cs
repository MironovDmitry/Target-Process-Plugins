// Generated by TinyPG v1.3 available at www.codeproject.com

// Disable unused variable warnings which
// can happen during the parser generation.
#pragma warning disable 168

namespace System.Linq.Dynamic
{

	#region Parser

	public partial class Parser
	{
		private readonly Scanner _scanner;
		private ParseTree tree;

		public Parser(Scanner scanner)
		{
			this._scanner = scanner;
		}

		public ParseTree Parse(string input)
		{
			return Parse(input, "", new ParseTree());
		}

		public ParseTree Parse(string input, string fileName)
		{
			return Parse(input, fileName, new ParseTree());
		}

		public ParseTree Parse(string input, string fileName, ParseTree tree)
		{
			_scanner.Init(input, fileName);

			this.tree = tree;
			ParseStart(tree);
			tree.Skipped = _scanner.Skipped;

			return tree;
		}

		private void ParseStart(ParseNode parent) // NonTerminalSymbol: Start
		{
			ParseNode node = parent.CreateNode(_scanner.GetToken(TokenType.Start), "Start");
			parent.Nodes.Add(node);


			// Concat Rule
			ParseExpression(node); // NonTerminal Rule: Expression

			// Concat Rule
			var tok = _scanner.Scan(TokenType.EOF);
			var n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.EOF)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(),
					0x1001, tok));
				return;
			}

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: Start

		private void ParseExpression(ParseNode parent) // NonTerminalSymbol: Expression
		{
			ParseNode node = parent.CreateNode(_scanner.GetToken(TokenType.Expression), "Expression");
			parent.Nodes.Add(node);


			// Concat Rule
			ParseLogicalOr(node); // NonTerminal Rule: LogicalOr

			// Concat Rule
			var tok = _scanner.LookAhead(TokenType.QUESTION);
			if (tok.Type == TokenType.QUESTION)
			{

				// Concat Rule
				tok = _scanner.Scan(TokenType.QUESTION); // Terminal Rule: QUESTION
				var n = node.CreateNode(tok, tok.ToString());
				node.Token.UpdateRange(tok);
				node.Nodes.Add(n);
				if (tok.Type != TokenType.QUESTION)
				{
					tree.Errors.Add(new ParseError(
						"Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.QUESTION.ToString(), 0x1001, tok));
					return;
				}

				// Concat Rule
				ParseExpression(node); // NonTerminal Rule: Expression

				// Concat Rule
				tok = _scanner.Scan(TokenType.COLON); // Terminal Rule: COLON
				n = node.CreateNode(tok, tok.ToString());
				node.Token.UpdateRange(tok);
				node.Nodes.Add(n);
				if (tok.Type != TokenType.COLON)
				{
					tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLON.ToString(),
						0x1001, tok));
					return;
				}

				// Concat Rule
				ParseExpression(node); // NonTerminal Rule: Expression
			}

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: Expression

		private void ParseLogicalOr(ParseNode parent) // NonTerminalSymbol: LogicalOr
		{
			ParseNode node = parent.CreateNode(_scanner.GetToken(TokenType.LogicalOr), "LogicalOr");
			parent.Nodes.Add(node);


			// Concat Rule
			ParseLogicalAnd(node); // NonTerminal Rule: LogicalAnd

			// Concat Rule
			var tok = _scanner.LookAhead(TokenType.OR);
			while (tok.Type == TokenType.OR)
			{

				// Concat Rule
				tok = _scanner.Scan(TokenType.OR); // Terminal Rule: OR
				var n = node.CreateNode(tok, tok.ToString());
				node.Token.UpdateRange(tok);
				node.Nodes.Add(n);
				if (tok.Type != TokenType.OR)
				{
					tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OR.ToString(),
						0x1001, tok));
					return;
				}

				// Concat Rule
				ParseLogicalAnd(node); // NonTerminal Rule: LogicalAnd
				tok = _scanner.LookAhead(TokenType.OR); // ZeroOrMore Rule
			}

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: LogicalOr

		private void ParseLogicalAnd(ParseNode parent) // NonTerminalSymbol: LogicalAnd
		{
			Token tok;
			ParseNode n;
			ParseNode node = parent.CreateNode(_scanner.GetToken(TokenType.LogicalAnd), "LogicalAnd");
			parent.Nodes.Add(node);


			// Concat Rule
			ParseComparison(node); // NonTerminal Rule: Comparison

			// Concat Rule
			tok = _scanner.LookAhead(TokenType.AND); // ZeroOrMore Rule
			while (tok.Type == TokenType.AND)
			{

				// Concat Rule
				tok = _scanner.Scan(TokenType.AND); // Terminal Rule: AND
				n = node.CreateNode(tok, tok.ToString());
				node.Token.UpdateRange(tok);
				node.Nodes.Add(n);
				if (tok.Type != TokenType.AND)
				{
					tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.AND.ToString(),
						0x1001, tok));
					return;
				}

				// Concat Rule
				ParseComparison(node); // NonTerminal Rule: Comparison
				tok = _scanner.LookAhead(TokenType.AND); // ZeroOrMore Rule
			}

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: LogicalAnd

		private void ParseComparison(ParseNode parent) // NonTerminalSymbol: Comparison
		{
			Token tok;
			ParseNode n;
			ParseNode node = parent.CreateNode(_scanner.GetToken(TokenType.Comparison), "Comparison");
			parent.Nodes.Add(node);


			// Concat Rule
			ParseAdditive(node); // NonTerminal Rule: Additive

			// Concat Rule
			tok = _scanner.LookAhead(TokenType.COMPARISON, TokenType.IN); // Option Rule
			if (tok.Type == TokenType.COMPARISON
				|| tok.Type == TokenType.IN)
			{
				tok = _scanner.LookAhead(TokenType.COMPARISON, TokenType.IN); // Choice Rule
				switch (tok.Type)
				{
					// Choice Rule
					case TokenType.COMPARISON:
						do
						{
							// OneOrMore Rule

							// Concat Rule
							tok = _scanner.Scan(TokenType.COMPARISON); // Terminal Rule: COMPARISON
							n = node.CreateNode(tok, tok.ToString());
							node.Token.UpdateRange(tok);
							node.Nodes.Add(n);
							if (tok.Type != TokenType.COMPARISON)
							{
								tree.Errors.Add(
									new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMPARISON.ToString(), 0x1001,
										tok));
								return;
							}

							// Concat Rule
							ParseAdditive(node); // NonTerminal Rule: Additive
							tok = _scanner.LookAhead(TokenType.COMPARISON); // OneOrMore Rule
						} while (tok.Type == TokenType.COMPARISON); // OneOrMore Rule
						break;
					case TokenType.IN:

						// Concat Rule
						tok = _scanner.Scan(TokenType.IN); // Terminal Rule: IN
						n = node.CreateNode(tok, tok.ToString());
						node.Token.UpdateRange(tok);
						node.Nodes.Add(n);
						if (tok.Type != TokenType.IN)
						{
							tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IN.ToString(),
								0x1001, tok));
							return;
						}

						// Concat Rule
						tok = _scanner.Scan(TokenType.OPENSQUARE); // Terminal Rule: OPENSQUARE
						n = node.CreateNode(tok, tok.ToString());
						node.Token.UpdateRange(tok);
						node.Nodes.Add(n);
						if (tok.Type != TokenType.OPENSQUARE)
						{
							tree.Errors.Add(
								new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPENSQUARE.ToString(), 0x1001,
									tok));
							return;
						}

						// Concat Rule
						ParseValueList(node); // NonTerminal Rule: ValueList

						// Concat Rule
						tok = _scanner.Scan(TokenType.CLOSESQUARE); // Terminal Rule: CLOSESQUARE
						n = node.CreateNode(tok, tok.ToString());
						node.Token.UpdateRange(tok);
						node.Nodes.Add(n);
						if (tok.Type != TokenType.CLOSESQUARE)
						{
							tree.Errors.Add(
								new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CLOSESQUARE.ToString(), 0x1001,
									tok));
							return;
						}
						break;
					default:
						tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected COMPARISON or IN.", 0x0002, tok));
						break;
				} // Choice Rule
			}

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: Comparison

		private void ParseValueList(ParseNode parent) // NonTerminalSymbol: ValueList
		{
			Token tok;
			ParseNode n;
			ParseNode node = parent.CreateNode(_scanner.GetToken(TokenType.ValueList), "ValueList");
			parent.Nodes.Add(node);


			// Concat Rule
			ParseExpression(node); // NonTerminal Rule: Expression

			// Concat Rule
			tok = _scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
			while (tok.Type == TokenType.COMMA)
			{

				// Concat Rule
				tok = _scanner.Scan(TokenType.COMMA); // Terminal Rule: COMMA
				n = node.CreateNode(tok, tok.ToString());
				node.Token.UpdateRange(tok);
				node.Nodes.Add(n);
				if (tok.Type != TokenType.COMMA)
				{
					tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(),
						0x1001, tok));
					return;
				}

				// Concat Rule
				ParseExpression(node); // NonTerminal Rule: Expression
				tok = _scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
			}

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: ValueList

		private void ParseAdditive(ParseNode parent) // NonTerminalSymbol: Additive
		{
			Token tok;
			ParseNode n;
			ParseNode node = parent.CreateNode(_scanner.GetToken(TokenType.Additive), "Additive");
			parent.Nodes.Add(node);


			// Concat Rule
			ParseMultiplicative(node); // NonTerminal Rule: Multiplicative

			// Concat Rule
			tok = _scanner.LookAhead(TokenType.ADDITIVE); // ZeroOrMore Rule
			while (tok.Type == TokenType.ADDITIVE)
			{

				// Concat Rule
				tok = _scanner.Scan(TokenType.ADDITIVE); // Terminal Rule: ADDITIVE
				n = node.CreateNode(tok, tok.ToString());
				node.Token.UpdateRange(tok);
				node.Nodes.Add(n);
				if (tok.Type != TokenType.ADDITIVE)
				{
					tree.Errors.Add(new ParseError(
						"Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ADDITIVE.ToString(), 0x1001, tok));
					return;
				}

				// Concat Rule
				ParseMultiplicative(node); // NonTerminal Rule: Multiplicative
				tok = _scanner.LookAhead(TokenType.ADDITIVE); // ZeroOrMore Rule
			}

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: Additive

		private void ParseMultiplicative(ParseNode parent) // NonTerminalSymbol: Multiplicative
		{
			Token tok;
			ParseNode n;
			ParseNode node = parent.CreateNode(_scanner.GetToken(TokenType.Multiplicative), "Multiplicative");
			parent.Nodes.Add(node);


			// Concat Rule
			ParseUnary(node); // NonTerminal Rule: Unary

			// Concat Rule
			tok = _scanner.LookAhead(TokenType.MULTIPLICATIVE); // ZeroOrMore Rule
			while (tok.Type == TokenType.MULTIPLICATIVE)
			{

				// Concat Rule
				tok = _scanner.Scan(TokenType.MULTIPLICATIVE); // Terminal Rule: MULTIPLICATIVE
				n = node.CreateNode(tok, tok.ToString());
				node.Token.UpdateRange(tok);
				node.Nodes.Add(n);
				if (tok.Type != TokenType.MULTIPLICATIVE)
				{
					tree.Errors.Add(
						new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MULTIPLICATIVE.ToString(), 0x1001,
							tok));
					return;
				}

				// Concat Rule
				ParseUnary(node); // NonTerminal Rule: Unary
				tok = _scanner.LookAhead(TokenType.MULTIPLICATIVE); // ZeroOrMore Rule
			}

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: Multiplicative

		private void ParseUnary(ParseNode parent) // NonTerminalSymbol: Unary
		{
			Token tok;
			ParseNode n;
			ParseNode node = parent.CreateNode(_scanner.GetToken(TokenType.Unary), "Unary");
			parent.Nodes.Add(node);


			// Concat Rule
			tok = _scanner.LookAhead(TokenType.UNARY); // Option Rule
			if (tok.Type == TokenType.UNARY)
			{
				tok = _scanner.Scan(TokenType.UNARY); // Terminal Rule: UNARY
				n = node.CreateNode(tok, tok.ToString());
				node.Token.UpdateRange(tok);
				node.Nodes.Add(n);
				if (tok.Type != TokenType.UNARY)
				{
					tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.UNARY.ToString(),
						0x1001, tok));
					return;
				}
			}

			// Concat Rule
			ParsePrimary(node); // NonTerminal Rule: Primary

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: Unary

		private void ParsePrimary(ParseNode parent) // NonTerminalSymbol: Primary
		{
			Token tok;
			ParseNode n;
			ParseNode node = parent.CreateNode(_scanner.GetToken(TokenType.Primary), "Primary");
			parent.Nodes.Add(node);

			tok = _scanner.LookAhead(TokenType.IDENTIFIER, TokenType.OPENCURLY, TokenType.NEW, TokenType.STRING, TokenType.INTEGER, TokenType.REAL,
				TokenType.OPENPAREN); // Choice Rule
			switch (tok.Type)
			{
				// Choice Rule
				case TokenType.IDENTIFIER:
					ParseStatement(node); // NonTerminal Rule: Statement
					break;
				case TokenType.OPENCURLY:
				case TokenType.NEW:
					ParseNewJson(node); // NonTerminal Rule: NewJson
					break;
				case TokenType.STRING:
				case TokenType.INTEGER:
				case TokenType.REAL:
					ParseValue(node); // NonTerminal Rule: Value
					break;
				case TokenType.OPENPAREN:

					// Concat Rule
					tok = _scanner.Scan(TokenType.OPENPAREN); // Terminal Rule: OPENPAREN
					n = node.CreateNode(tok, tok.ToString());
					node.Token.UpdateRange(tok);
					node.Nodes.Add(n);
					if (tok.Type != TokenType.OPENPAREN)
					{
						tree.Errors.Add(
							new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPENPAREN.ToString(), 0x1001, tok));
						return;
					}

					// Concat Rule
					ParseExpression(node); // NonTerminal Rule: Expression

					// Concat Rule
					tok = _scanner.Scan(TokenType.CLOSEPAREN); // Terminal Rule: CLOSEPAREN
					n = node.CreateNode(tok, tok.ToString());
					node.Token.UpdateRange(tok);
					node.Nodes.Add(n);
					if (tok.Type != TokenType.CLOSEPAREN)
					{
						tree.Errors.Add(
							new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CLOSEPAREN.ToString(), 0x1001,
								tok));
						return;
					}
					break;
				default:
					tree.Errors.Add(
						new ParseError(
							"Unexpected token '" + tok.Text.Replace("\n", "")
								+ "' found. Expected IDENTIFIER, OPENCURLY, NEW, STRING, INTEGER, REAL, or OPENPAREN.", 0x0002, tok));
					break;
			} // Choice Rule

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: Primary

		private void ParseValue(ParseNode parent) // NonTerminalSymbol: Value
		{
			Token tok;
			ParseNode n;
			ParseNode node = parent.CreateNode(_scanner.GetToken(TokenType.Value), "Value");
			parent.Nodes.Add(node);

			tok = _scanner.LookAhead(TokenType.STRING, TokenType.INTEGER, TokenType.REAL); // Choice Rule
			switch (tok.Type)
			{
				// Choice Rule
				case TokenType.STRING:
					tok = _scanner.Scan(TokenType.STRING); // Terminal Rule: STRING
					n = node.CreateNode(tok, tok.ToString());
					node.Token.UpdateRange(tok);
					node.Nodes.Add(n);
					if (tok.Type != TokenType.STRING)
					{
						tree.Errors.Add(new ParseError(
							"Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING.ToString(), 0x1001, tok));
						return;
					}
					break;
				case TokenType.INTEGER:
					tok = _scanner.Scan(TokenType.INTEGER); // Terminal Rule: INTEGER
					n = node.CreateNode(tok, tok.ToString());
					node.Token.UpdateRange(tok);
					node.Nodes.Add(n);
					if (tok.Type != TokenType.INTEGER)
					{
						tree.Errors.Add(new ParseError(
							"Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INTEGER.ToString(), 0x1001, tok));
						return;
					}
					break;
				case TokenType.REAL:
					tok = _scanner.Scan(TokenType.REAL); // Terminal Rule: REAL
					n = node.CreateNode(tok, tok.ToString());
					node.Token.UpdateRange(tok);
					node.Nodes.Add(n);
					if (tok.Type != TokenType.REAL)
					{
						tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.REAL.ToString(),
							0x1001, tok));
						return;
					}
					break;
				default:
					tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected STRING, INTEGER, or REAL.",
						0x0002, tok));
					break;
			} // Choice Rule

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: Value

		private void ParseNewJson(ParseNode parent) // NonTerminalSymbol: NewJson
		{
			Token tok;
			ParseNode n;
			ParseNode node = parent.CreateNode(_scanner.GetToken(TokenType.NewJson), "NewJson");
			parent.Nodes.Add(node);

			tok = _scanner.LookAhead(TokenType.OPENCURLY, TokenType.NEW); // Choice Rule
			switch (tok.Type)
			{
				// Choice Rule
				case TokenType.OPENCURLY:

					// Concat Rule
					tok = _scanner.Scan(TokenType.OPENCURLY); // Terminal Rule: OPENCURLY
					n = node.CreateNode(tok, tok.ToString());
					node.Token.UpdateRange(tok);
					node.Nodes.Add(n);
					if (tok.Type != TokenType.OPENCURLY)
					{
						tree.Errors.Add(
							new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPENCURLY.ToString(), 0x1001, tok));
						return;
					}

					// Concat Rule
					ParseField(node); // NonTerminal Rule: Field

					// Concat Rule
					tok = _scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
					while (tok.Type == TokenType.COMMA)
					{

						// Concat Rule
						tok = _scanner.Scan(TokenType.COMMA); // Terminal Rule: COMMA
						n = node.CreateNode(tok, tok.ToString());
						node.Token.UpdateRange(tok);
						node.Nodes.Add(n);
						if (tok.Type != TokenType.COMMA)
						{
							tree.Errors.Add(new ParseError(
								"Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, tok));
							return;
						}

						// Concat Rule
						ParseField(node); // NonTerminal Rule: Field
						tok = _scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
					}

					// Concat Rule
					tok = _scanner.Scan(TokenType.CLOSECURLY); // Terminal Rule: CLOSECURLY
					n = node.CreateNode(tok, tok.ToString());
					node.Token.UpdateRange(tok);
					node.Nodes.Add(n);
					if (tok.Type != TokenType.CLOSECURLY)
					{
						tree.Errors.Add(
							new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CLOSECURLY.ToString(), 0x1001,
								tok));
						return;
					}
					break;
				case TokenType.NEW:

					// Concat Rule
					tok = _scanner.Scan(TokenType.NEW); // Terminal Rule: NEW
					n = node.CreateNode(tok, tok.ToString());
					node.Token.UpdateRange(tok);
					node.Nodes.Add(n);
					if (tok.Type != TokenType.NEW)
					{
						tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NEW.ToString(),
							0x1001, tok));
						return;
					}

					// Concat Rule
					tok = _scanner.Scan(TokenType.OPENPAREN); // Terminal Rule: OPENPAREN
					n = node.CreateNode(tok, tok.ToString());
					node.Token.UpdateRange(tok);
					node.Nodes.Add(n);
					if (tok.Type != TokenType.OPENPAREN)
					{
						tree.Errors.Add(
							new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPENPAREN.ToString(), 0x1001, tok));
						return;
					}

					// Concat Rule
					ParseField(node); // NonTerminal Rule: Field

					// Concat Rule
					tok = _scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
					while (tok.Type == TokenType.COMMA)
					{

						// Concat Rule
						tok = _scanner.Scan(TokenType.COMMA); // Terminal Rule: COMMA
						n = node.CreateNode(tok, tok.ToString());
						node.Token.UpdateRange(tok);
						node.Nodes.Add(n);
						if (tok.Type != TokenType.COMMA)
						{
							tree.Errors.Add(new ParseError(
								"Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, tok));
							return;
						}

						// Concat Rule
						ParseField(node); // NonTerminal Rule: Field
						tok = _scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
					}

					// Concat Rule
					tok = _scanner.Scan(TokenType.CLOSEPAREN); // Terminal Rule: CLOSEPAREN
					n = node.CreateNode(tok, tok.ToString());
					node.Token.UpdateRange(tok);
					node.Nodes.Add(n);
					if (tok.Type != TokenType.CLOSEPAREN)
					{
						tree.Errors.Add(
							new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CLOSEPAREN.ToString(), 0x1001,
								tok));
						return;
					}
					break;
				default:
					tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected OPENCURLY or NEW.", 0x0002, tok));
					break;
			} // Choice Rule

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: NewJson

		private void ParseField(ParseNode parent) // NonTerminalSymbol: Field
		{
			Token tok;
			ParseNode n;
			ParseNode node = parent.CreateNode(_scanner.GetToken(TokenType.Field), "Field");
			parent.Nodes.Add(node);


			// Concat Rule
			tok = _scanner.LookAhead(TokenType.SEMICOLONNAME); // Option Rule
			if (tok.Type == TokenType.SEMICOLONNAME)
			{
				tok = _scanner.Scan(TokenType.SEMICOLONNAME); // Terminal Rule: SEMICOLONNAME
				n = node.CreateNode(tok, tok.ToString());
				node.Token.UpdateRange(tok);
				node.Nodes.Add(n);
				if (tok.Type != TokenType.SEMICOLONNAME)
				{
					tree.Errors.Add(
						new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SEMICOLONNAME.ToString(), 0x1001,
							tok));
					return;
				}
			}

			// Concat Rule
			ParseExpression(node); // NonTerminal Rule: Expression

			// Concat Rule
			tok = _scanner.LookAhead(TokenType.ASNAME); // Option Rule
			if (tok.Type == TokenType.ASNAME)
			{
				tok = _scanner.Scan(TokenType.ASNAME); // Terminal Rule: ASNAME
				n = node.CreateNode(tok, tok.ToString());
				node.Token.UpdateRange(tok);
				node.Nodes.Add(n);
				if (tok.Type != TokenType.ASNAME)
				{
					tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ASNAME.ToString(),
						0x1001, tok));
					return;
				}
			}

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: Field

		private void ParseStatement(ParseNode parent) // NonTerminalSymbol: Statement
		{
			Token tok;
			ParseNode n;
			ParseNode node = parent.CreateNode(_scanner.GetToken(TokenType.Statement), "Statement");
			parent.Nodes.Add(node);


			// Concat Rule
			tok = _scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.IDENTIFIER)
			{
				tree.Errors.Add(
					new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
				return;
			}

			// Concat Rule
			tok = _scanner.LookAhead(TokenType.OPENPAREN, TokenType.OPENSQUARE); // Option Rule
			if (tok.Type == TokenType.OPENPAREN
				|| tok.Type == TokenType.OPENSQUARE)
			{
				ParseCall(node); // NonTerminal Rule: Call
			}

			// Concat Rule
			tok = _scanner.LookAhead(TokenType.DOT); // Option Rule
			if (tok.Type == TokenType.DOT)
			{

				// Concat Rule
				tok = _scanner.Scan(TokenType.DOT); // Terminal Rule: DOT
				n = node.CreateNode(tok, tok.ToString());
				node.Token.UpdateRange(tok);
				node.Nodes.Add(n);
				if (tok.Type != TokenType.DOT)
				{
					tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOT.ToString(),
						0x1001, tok));
					return;
				}

				// Concat Rule
				ParseStatement(node); // NonTerminal Rule: Statement
			}

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: Statement

		private void ParseCall(ParseNode parent) // NonTerminalSymbol: Call
		{
			Token tok;
			ParseNode n;
			ParseNode node = parent.CreateNode(_scanner.GetToken(TokenType.Call), "Call");
			parent.Nodes.Add(node);

			tok = _scanner.LookAhead(TokenType.OPENPAREN, TokenType.OPENSQUARE); // Choice Rule
			switch (tok.Type)
			{
				// Choice Rule
				case TokenType.OPENPAREN:

					// Concat Rule
					tok = _scanner.Scan(TokenType.OPENPAREN); // Terminal Rule: OPENPAREN
					n = node.CreateNode(tok, tok.ToString());
					node.Token.UpdateRange(tok);
					node.Nodes.Add(n);
					if (tok.Type != TokenType.OPENPAREN)
					{
						tree.Errors.Add(
							new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPENPAREN.ToString(), 0x1001, tok));
						return;
					}

					// Concat Rule
					tok = _scanner.LookAhead(TokenType.UNARY, TokenType.IDENTIFIER, TokenType.OPENCURLY, TokenType.NEW, TokenType.STRING, TokenType.INTEGER,
						TokenType.REAL, TokenType.OPENPAREN); // Option Rule
					if (tok.Type == TokenType.UNARY
						|| tok.Type == TokenType.IDENTIFIER
						|| tok.Type == TokenType.OPENCURLY
						|| tok.Type == TokenType.NEW
						|| tok.Type == TokenType.STRING
						|| tok.Type == TokenType.INTEGER
						|| tok.Type == TokenType.REAL
						|| tok.Type == TokenType.OPENPAREN)
					{
						ParseValueList(node); // NonTerminal Rule: ValueList
					}

					// Concat Rule
					tok = _scanner.Scan(TokenType.CLOSEPAREN); // Terminal Rule: CLOSEPAREN
					n = node.CreateNode(tok, tok.ToString());
					node.Token.UpdateRange(tok);
					node.Nodes.Add(n);
					if (tok.Type != TokenType.CLOSEPAREN)
					{
						tree.Errors.Add(
							new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CLOSEPAREN.ToString(), 0x1001,
								tok));
						return;
					}
					break;
				case TokenType.OPENSQUARE:

					// Concat Rule
					tok = _scanner.Scan(TokenType.OPENSQUARE); // Terminal Rule: OPENSQUARE
					n = node.CreateNode(tok, tok.ToString());
					node.Token.UpdateRange(tok);
					node.Nodes.Add(n);
					if (tok.Type != TokenType.OPENSQUARE)
					{
						tree.Errors.Add(
							new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPENSQUARE.ToString(), 0x1001,
								tok));
						return;
					}

					// Concat Rule
					ParseValueList(node); // NonTerminal Rule: ValueList

					// Concat Rule
					tok = _scanner.Scan(TokenType.CLOSESQUARE); // Terminal Rule: CLOSESQUARE
					n = node.CreateNode(tok, tok.ToString());
					node.Token.UpdateRange(tok);
					node.Nodes.Add(n);
					if (tok.Type != TokenType.CLOSESQUARE)
					{
						tree.Errors.Add(
							new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CLOSESQUARE.ToString(), 0x1001,
								tok));
						return;
					}
					break;
				default:
					tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected OPENPAREN or OPENSQUARE.", 0x0002,
						tok));
					break;
			} // Choice Rule

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: Call


	}

	#endregion Parser
}
